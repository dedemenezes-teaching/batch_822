让我们为餐厅开发一个送餐程序吧！

以下是我们应用程序的第一个 **用户操作**：
- 作为一个用户，我可以添加一个新的餐meal
- 作为一个用户，我可以列出所有的餐meals
- 作为一个用户，我可以添加一个新顾客customer
- 作为一个用户，我可以列出所有的顾客customers

**警告**

该软件专为 **一家餐厅** 设计，因此无需满足多家餐厅的需要（例如，我们不需要 `餐厅` 模型）。
该软件是专为 **餐厅的工作人员** 设计的，因此无需为顾客设计登录界面。
因此，我们软件的第一个组件是：
- **餐** **Meals**
- **顾客** **Customers**

## 1 - `餐 Meals`

### 1.1 - `餐 Meal`模型

我们的餐厅卖餐 meals，所以我们需要一种方法来表示餐 meal 是什么。

每一个餐meal都有id、 name 和 price。

编写一些代码来实现这一点，并对模型进行崩溃测试。然后通过运行 `rake meal` 来测试代码。

都是绿色的？很好！是时候 `git add`, `commit` 和 `push` 了。

### 1.2 - `餐 Meal` 存储库

现在我们有了一个代表我们的餐 meal 的模型，我们需要一个存储库来存储它们。

此存储库使用CSV文件路径初始化。它从CSV文件中读取/写入食物，并将它们作为对象保存在一个数组中。我们希望存储库可以执行以下操作：

- 添加新餐meal
- 得到所有的餐meals
- 用id找到一个特定的餐meal

编写一些代码来实现这一点，并对模型进行崩溃测试。你应该在 `data` 文件夹中创建自己的 `meals.csv` CSV文件。然后通过运行 `rake meal` 来测试代码。

都是绿色的？很好！是时候 `git add`, `commit` 和 `push` 了。

### 1.3 - 路由和应用程序

我们还没有启动我们的应用程序。为此，我们需要一个router路由，并且需要填写 `app.rb` 文件。

路由router负责显示用户可以执行的任务，并将用户的选择路由到匹配控制器的相应操作。 `app.rb` 文件负责要求所有必需的文件，实例化路由并执行其 `run` 方法来启动应用程序。

填写 `router.rb` 和 `app.rb` 文件来实现这一点。如果你被困住了，你可以回到[Cookbook第二天](https://kitt.lewagon.com/camps/<user.batch_slug>/challenges?path=02-OOP%2F04-Cookbook-Day-Two%2F01-Cookbook-Advanced) 并下载答案以获得一些灵感 **无需将路由器与控制器关联**，因为我们还没有。所以当用户选择任务时，只需打印 `TODO` 。

这部分没有rake。通过在终端中运行以下命令启动应用程序：

```bash
ruby app.rb
```

都是绿色的？很好！是时候 `git add`, `commit` 和 `push` 了。

### 1.4 - `餐 Meals` 控制器

让我们转到控制器。下面是我们要实现的 **用户操作**：
- `add` 加一个新meal
- `list` 列出所有meals

请记住，控制器的角色是将工作委派给应用程序的其他组件（模型、存储库和视图）并进行协调！

首先编写 **伪代码**，将每个用户操作分解为基本步骤，并将每个步骤委托给一个组件（模型、存储库或视图）。然后编写代码来实现每个步骤。创建视图并逐步编写代码。

要测试你的控制器，请通过在 `app.rb` 中实例化它并将其传递给路由器，将它链接到你的应用程序。然后，你可以通过启动应用程序对代码进行崩溃测试：

```bash
ruby app.rb
```

`rake meal` 也会帮助你完成所有这些步骤。跟着你的向导走！

在继续下一个功能之前，请确保你的两个用户操作正常。

都是绿色的？很好！是时候 `git add`, `commit` 和 `push` 了。

## 2 - `顾客 Customers`

### 2.1 - `顾客 Customer` 模型

我们的餐厅是面对顾客customers的，所以我们需要一种方式来代表顾客customer是什么。
每个顾客customer都有一个id、一个name和一个address。

编写一些代码来实现这一点，并对模型进行崩溃测试。然后通过运行 `rake customer`来测试代码。

都是绿色的？很好！是时候 `git add`, `commit` 和 `push` 了。

### 2.2 - `顾客 Customer` 存储库

现在我们有了一个代表customers的模型，我们需要一个存储库来存储它们。
此存储库使用CSV文件路径初始化。它从CSV文件中读取/写入customers，并将其作为数组中的对象保存。我们希望存储库可以执行以下操作：
- 添加新customer
- 抓住所有的customers
- 通过id查找特定customer
编写一些代码来实现这一点，并对存储库进行崩溃测试。你应该在 `data` 文件夹中创建自己的 `customers.csv` CSV文件。然后通过运行 `rake customer` 来测试代码。

都是绿色的？很好！是时候 `git add`, `commit` 和 `push` 了。

### 2.3 - 控制器

让我们转到控制器。下面是我们要实现的 **用户操作**：
- `add` 一个新customer
- `list` 所有Customers

请记住，控制器的角色是将工作委派给应用程序的其他组件（模型、存储库和视图）并进行协调！

首先编写 **伪代码**，将每个用户操作分解为基本步骤，并将每个步骤委托给一个组件（模型、存储库或视图）。然后编写代码来实现每个步骤。创建视图并逐步编写代码。

要测试你的控制器？请通过在 `app.rb` 中实例化它并将其传递给路由器，将它链接到你的应用程序。然后，你可以通过启动应用程序对代码进行崩溃测试：

```bash
ruby app.rb
```

`rake customer` 也会帮助你完成所有这些步骤。跟着你的向导走！

在继续下一个功能之前，请确保你的两个用户操作正常。

都是绿色的？很好！是时候 `git add`, `commit` 和 `push` 了。

## 3 - 选做部分

### 3.1 - 对餐 meals 和 顾客customers 实施 `edit` 和 `destroy` 操作

在我们的应用程序中，用户不能编辑或删除现有的meal或customer。

实现这些附加用户操作：
- 作为一个用户，我可以编辑现有的餐meal
- 作为一个用户，我可以销毁现有的餐meal
- 作为用户，我可以编辑现有的顾客customer
- 作为一个用户，我可以删除一个现有的顾客customer

完成了？很好！是时候 `git add`, `commit` 和 `push` 了。

### 3.2 - Refactor repositories with inheritance

`MealRepository` 和 `CustomerRepository` 有很多相似之处，不是吗？为了保持[DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) (需要VPN 🛡 ), ，我们需要定义一个父类,`BaseRepository`，它有所有 `MealRepository` 和`CustomerRepository` 共同分享的行为会从中继承。

写一些代码来实现这个。这是一个重构过程，所以这部分没有新的测试。如果你的 `rake` 以前都是绿色的，那以后应该都是绿色的！

完成了？很好！是时候 `git add`, `commit` 和 `push` 了。

你完成今天的挑战啦！
